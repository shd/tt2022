\documentclass[10pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{comment}
\usepackage{cmll}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\usepackage{tikz}
\usepackage{multicol}

\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
  \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\newtheorem{definition}{Определение}
\begin{document}

\begin{center}{\Large\textsc{\textbf{Теоретические домашние задания}}}\\
             \it Теория типов, ИТМО, М3235-М3239, осень 2022 года\end{center}

\section*{Домашнее задание №1: <<вводная лекция>>}

\begin{enumerate}

\item Напомним определения с лекций:

\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$T$ & $\lambda a.\lambda b.a$ & истина\\
$F$ & $\lambda a.\lambda b.b$ & ложь\\
$Not$ & $\lambda x.x\ F\ T$ & отрицание\\
$And$ & $\lambda x.\lambda y.x\ y\ F$ & конъюнкция
\end{tabular}

Постройте лямбда-выражения для следующих булевских выражений:
\begin{enumerate}
\item Штрих Шеффера (<<и-не>>)
\item Стрелка Пирса (<<или-не>>)
\item Мажоритарный элемент от трёх аргументов (результат <<истина>>, если истинны не менее двух аргументов)
\end{enumerate}

\item Напомним определения с лекций:

$$f^{(n)}\ X ::= \left\{\begin{array}{ll} X, & n=0\\
                                f^{(n-1)}\ (f\ X), & n>0\end{array}\right.$$

\begin{center}\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$\overline{n}$ & $\lambda f.\lambda x.f^{(n)}\ x$ & чёрчевский нумерал\\
$(+1)$ & $\lambda n.\lambda f.\lambda x.n\ f\ (f\ x)$ & прибавление 1\\
$IsZero$ & $\lambda n.n\ (\lambda x.F)\ T$ & проверка на 0
\end{tabular}\end{center}

\begin{center}\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$MkPair$ & $\lambda a.\lambda b.(\lambda x.x\ a\ b)$ & создание пары\\
$PrL$ & $\lambda p.p\ T$ & левая проекция\\
$PrR$ & $\lambda p.p\ F$ & правая проекция\\\hline
$Case$ & $\lambda l.\lambda r.\lambda c.c\ l\ r$ & case для алгебраического типа\\
$InL$ & $\lambda l.(\lambda x.\lambda y.x\ l)$ & левая инъекция\\
$InR$ & $\lambda r.(\lambda x.\lambda y.y\ r)$ & правая инъекция\\
\end{tabular}\end{center}

Используя данные определения, постройте выражения для следующих операций над числами:

\begin{enumerate}
\item Вычитание 1
\item Вычитание
\item Деление
\item Сравнение двух чисел ($IsLess$) — истина, если первый аргумент меньше второго
(могут потребоваться пары и/или вычитания)
\item Делимость
\end{enumerate}

\item Проредуцируйте выражение и найдите его нормальную форму: 
\begin{enumerate}
\item $\overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}$
\end{enumerate}

\item Напомним определение Y-комбинатора: $\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$.
\begin{enumerate}
\item Покажите, что выражение $Y\ f$ не имеет нормальной формы;
\item Покажите, что выражение $Y\ (\lambda f.\overline{0})$ имеет нормальную форму.
\item Покажите, что выражение $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ (f\ Minus1\ x))\ 2$ имеет нормальную форму.
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ ((+1)\ (f\ Minus1\ x)))\ \overline{n}$?
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{1}\ (Mul2\ (f\ Minus1\ x)))\ \overline{n}$?
\item Определите с помощью $Y$-комбинатора функцию для вычисления $n$-го числа Фибоначчи.
\end{enumerate}

\item Определим на языке Хаскель следующую функцию: \verb!show_church n = show (n (+1) 0)!
Убедитесь, что \verb!show_church (\f -> \x -> f (f x))! вернёт 2. 
Пользуясь данным определением и его идеей, реализуйте следующие функции:

\begin{enumerate}
\item \verb!int_to_church! --- возвращает чёрчевский нумерал (т.е. функцию от двух аргументов) по целому числу.
Каков точный тип результата этой функции?
\item сложение двух чёрчевских нумералов.
\item умножение двух чёрчевских нумералов.
\item можно ли определить вычитание 1 и вычитание? Что получается, а что --- нет?
\end{enumerate}

\item На лекции было использовано понятие свободы для подстановки. 
\begin{enumerate}
\item Найдите лямбда-выражение, которое при однократной редукции требует переименования связанных переменных
(редукция невозможна без переименования). 
\item Заметим, что даже если мы запретим использовать одни и те же переменные в разных лямбда-абстракциях,
это не будет решением проблемы переименований. Предложите лямбда-выражение, в котором (а) все лямбда-абстракции
указаны по разным переменным; но (б) через некоторое количество редукций потребуется переименование
связанных переменных.
\end{enumerate}

\item Дадим определение: комбинатор --- лямбда-выражение без свободных переменных.

Также напомним определение:
$$\begin{array}{l}
S := \lambda x.\lambda y.\lambda z.x\ z\ (y\ z)\\
K := \lambda x.\lambda y.x\\
I := \lambda x.x
\end{array}$$

Известна теорема о том, что для любого комбинатора $X$ можно найти выражение $P$
(состоящее только из скобок, пробелов и комбинаторов $S$ и $K$), что $X =_\beta P$.
Будем говорить, что комбинатор $P$ \emph{выражает} комбинатор $X$ в базисе $SK$.

Выразите в базисе $SK$:
\begin{enumerate}
\item $F = \lambda x.\lambda y.y$
\item $\overline{1}$
\item $Not$
\item $Xor$
\item $InL$
\end{enumerate}

\item Чёрчевские нумералы соответствуют натуральным числам в аксиоматике Пеано.
\begin{enumerate}
\item Предложите <<двоичные нумералы>> --- способ кодирования чисел, аналогичный двоичной системе 
(такой, при котором длина записи числа соответствует логарифму числового значения).
\item Предложите реализацию функции (+1) в данном представлении.
\item Предложите реализацию лямбда-выражения преобразования числа из двоичного нумерала в чёрчевский.
\item Предложите реализацию функции сложения в данном представлении.
\item Предложите реализацию функции вычитания в данном представлении.
\item Какова вычислительная сложность арифметопераций с двоичными нумералами?
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №2: ещё о бестиповом лямбда-исчислении}

\begin{enumerate}
\item Бесконечное количество комбинаторов неподвижной точки. Дадим следующие определения
$$\begin{array}{l}
L := \lambda abcdefghijklmnopqstuvwxyzr.r(thisisafixedpointcombinator)\\
R := LLLLLLLLLLLLLLLLLLLLLLLLLL\end{array}$$
В данном определении терм $R$ является комбинатором неподвижной точки: каков бы ни был терм
$F$, выполнено $R\ F =_\beta F\ (R\ F)$.
\begin{enumerate}
\item Докажите, что данный комбинатор --- действительно комбинатор неподвижной точки.
\item Пусть в качестве имён переменных разрешены русские буквы. Постройте аналогичное выражение
по-русски: с 33 параметрами и осмысленной русской фразой в терме $L$; покажите, что оно является
комбинатором неподвижной точки.
\end{enumerate}

\item Напомним определение аппликативного порядка редукции:
редуцируется самый левый из самых вложенных редексов. Например, в случае выражения
$(\lambda x.I\ I)\ (\lambda y.I\ I)$ самые вложенные редексы --- применения $I\ I$:

$$(\lambda x.\underline{I\ I})\ (\lambda y.\underline{I\ I})$$

и надо выбрать самый левый из них:

$$(\lambda x.\underline{I\ I})\ (\lambda y.I\ I)$$
\begin{enumerate}
\item Проведите аппликативную редукцию выражения $2\ 2$.
\item Постройте выражение, использующее $Y$-комбинатор для вычисления факториала. 
Возможно ли его аппликативное вычисление, или оно не сможет завершиться?
\item Найдите лямбда-выражение, которое редуцируется медленнее при нормальном порядке редукции,
чем при аппликативном, даже при наличии мемоизации.
\end{enumerate}

\item Будем говорить, что выражение $A$ находится в \emph{слабой заголовочной нормальной форме} (WHNF),
если оно не имеет вид $A \equiv (\lambda x.P)\ Q$ (то есть, самый верхний терм его не является редексом).
Выражение находится в \emph{заголовочной нормальной форме} (HNF), когда его верхний терм --- не редекс и не лямбда-абстракция
с бета-редексами в теле.

Верно ли, что <<нормальность>> формы выражения может в процессе редукции только усиливаться
(никакая --- слабая заголовочная Н.Ф. --- заголовочная Н.Ф. --- нормальная форма)?

\item Заметим, что список в лямбда-выражении можно закодировать с помощью алгебраических типов.
Напишите лямбда-выражение для:
\begin{enumerate}
\item вычисления длины списка;
\item функции $map$ (построение нового списка из результатов применения функции к элементам старого);
\item суммы списка целых чисел.
\end{enumerate} 

\item Базис $SKI$ не единственный. Рассмотрим базис $BCKW$:
$$\begin{array}{l}B = \lambda x.\lambda y.\lambda z.x\ (y\ z)\\
C = \lambda x.\lambda y.\lambda z.x\ z\ y\\
K = \lambda x.\lambda y.x\\
W = \lambda x.\lambda y.x\ y\ y\end{array}$$

\begin{enumerate}
\item Покажите, что базис $BCKW$ позволяет выразить любое выражение из базиса $SKI$.
\item Покажите, что любое выражение из базиса $BCKW$ может быть выражено в базисе $SKI$.
\end{enumerate}
\end{enumerate}


\section*{Домашнее задание №3: просто-типизированное лямбда-исчисление}
\begin{enumerate}

\item Пусть фиксирован тип чёрчевского нумерала $\eta = (\alpha\rightarrow\alpha) \rightarrow (\alpha\rightarrow\alpha)$. 
Найдите тип для следующих конструкций и постройте доказательство:
\begin{enumerate}
\item $\overline{2}$ (покажите, что его тип --- $\eta$).
\item $(+1)$.
\item $Plus$.
\item $Mul$ (не каждая реализация умножения имеет тип в просто-типизированном лямбда исчислении;
вам требуется найти нужную)
\end{enumerate}

\item Имеет ли тип --- и какой:
\begin{enumerate}
\item операция вычитания 1 (выраженная через <<трюк зуба мудрости>>)? Общий ответ не требуется, 
достаточно рассмотреть какую-то одну реализацию.
\item операция вычитания ($\lambda m.\lambda n.m\ (-1)\ n$)?
\item операция возведения в степень ($Power ::= \lambda m.\lambda n.n\ m$)? 
\item функция $\lambda x.Power\ x\ x$?
\end{enumerate}

\item Каков тип:
\begin{enumerate}
\item комбинаторов $S$ и $K$;
\item истины и лжи.
\end{enumerate}

\item Рассмотрим полную интуиционистскую логику, с конъюнкцией, дизъюнкцией и ложью. Какой тип у следующих конструкций,
и какие правила вывода интуиционистской логики им соответстсвуют (ответ требует демонстрации корректности этих правил
для данных конструкций --- то есть вывод про тип результата применения правила должен всегда иметь место для выражений
соответствующего вида):
\begin{enumerate}
\item Упорядоченная пара (MkPair, PrL, PrR).
\item Алгебраический тип (InL: $\lambda x.\lambda a.\lambda b.a\ x$, InR: $\lambda x.\lambda a.\lambda b.b\ x$, Case).
\end{enumerate}

%\item Предложим альтернативные аксиомы для конъюнкции:
%
%$$\infer[\text{Введ. }\with]{\Gamma\vdash \alpha\with \beta}{\Gamma\vdash \alpha\ \ \ \Gamma\vdash \beta}\quad\quad
%  \infer[\text{Удал. }\with]{\Gamma\vdash \gamma}{\Gamma\vdash \alpha\with \beta\ \ \ \Gamma, \alpha, \beta\vdash \gamma}$$
%
%\begin{enumerate}                                                             
%\item Предложите лямбда-выражения, соответствующие данным аксиомам; поясните, как данные выражения 
%абстрагируют понятие <<упорядоченной пары>>.
%\item Выразите изложенные в лекции аксиомы конъюнкции через приведённые в условии.
%\item Выразите приведённые в условии аксиомы конъюнкции через изложенные в лекции.
%\end{enumerate}

\item Докажите лемму о редукции (subject reduction lemma): если $A \twoheadrightarrow_\beta B$ и $\vdash A: \tau$, то
$\vdash B: \tau$.

Верно ли обратное: если $A \twoheadrightarrow_\beta B$ и $\vdash B: \tau$, то
$\vdash A: \tau$?

\item Как мы уже разбирали, $\not\vdash x\ x:\tau$ в силу дополнительных ограничений
правила
$$\infer[x \notin FV(\Gamma)]{\Gamma, x:\tau\vdash x:\tau}{}$$

Найдите лямбда-выражение $N$, что $\not\vdash N:\tau$ в силу ограничений правила
$$\infer[x \notin FV(\Gamma)]{\Gamma \vdash \lambda x.N:\sigma\to\tau}{\Gamma, x:\sigma \vdash N:\tau}$$

\item Верно ли, что $S = B(BW)(BBC)$? Если нет, то как правильно?
\end{enumerate}

\section*{Домашнее задание №4: <<Изоморфизм Карри-Ховарда>>}

\begin{enumerate}
\item Предложим альтернативные аксиомы для конъюнкции:

$$\infer[\text{Введ. }\with]{\Gamma\vdash \alpha\with \beta}{\Gamma\vdash \alpha\ \ \ \Gamma\vdash \beta}\quad\quad
  \infer[\text{Удал. }\with]{\Gamma\vdash \gamma}{\Gamma\vdash \alpha\with \beta\ \ \ \Gamma, \alpha, \beta\vdash \gamma}$$

\begin{enumerate}
\item Предложите лямбда-выражения, соответствующие данным аксиомам; поясните, как данные выражения 
абстрагируют понятие <<упорядоченной пары>>.
\item Выразите изложенные в лекции аксиомы конъюнкции через приведённые в условии.
\item Выразите приведённые в условии аксиомы конъюнкции через изложенные в лекции.
\end{enumerate}

\item \emph{Вполне упорядоченным} множеством назовём такое линейно-упорядоченное отношением $(\prec)$ 
множество $S$ (и такой порядок назовём \emph{полным}), 
что какое бы ни было множество $U \subseteq S$, в $U$ найдётся наименьший элемент.
\begin{enumerate}
\item Покажите, что неотрицательные вещественные числа $[0,+\inf)$ --- не вполне упорядоченное множество.
Существуют ли конечные и счётные не вполне упорядоченные множества?
\item Определим лексикографический порядок на $\mathbb{N}^n$: положим, что 
$\langle a_1, a_2, \dots a_n \rangle \prec \langle b_1, b_2, \dots b_n$, если найдётся такой $k$,
что $a_1 = b_1$, ..., $a_{k-1} = b_{k-1}$, но $a_k < b_k$.
Покажите, что такой порядок --- полный.
\item Пусть $S$ вполне упорядочено отношением $(\prec)$, 
определим $a\succ b := b \prec a$. Пусть $a_1 \succ a_2 \succ a_3 \succ \dots$ --- 
строго монотонно убывающая последовательность значений из $S$. Покажите, что данная 
последовательность всегда имеет конечную длину.
\end{enumerate}

\item Поясним название <<алгебраические типы>> --- это семейство составных типов, 
позволяющих строить <<алгебраические>> выражения на типах:

\begin{tabular}{lll}
название & обозначение & алгебраический смысл\\\hline
тип-сумма, <<алгебраический>> & $\alpha\vee\beta$ & $\alpha+\beta$\\
тип-произведение, пара & $\alpha\with\beta$ & $\alpha\times\beta$\\
тип-степень, функция & $\alpha\to\beta$&$\beta^\alpha$
\end{tabular}

Название <<алгебраический>> закрепилось в первую очередь за типом-суммой (видимо потому,
что остальные типы имеют устоявшиеся названия), однако, может быть отнесено и к другим
типам.

Поясните <<типовый>> (программистский) смысл следующих алгебраических тождеств --- и постройте
программы на Хаскеле, их доказывающие:
\begin{enumerate}
\item $\gamma\times(\alpha+\beta) = \gamma\times\alpha + \gamma\times\beta$.
\item $\gamma^{\alpha\times\beta} = {(\gamma^\alpha)}^\beta$. Как называется данное тождество?
\item $\gamma^{\alpha+\beta} = \gamma^\alpha\times\gamma^\beta$.
\end{enumerate}

\item Напомним, что $\neg\alpha \equiv \alpha\rightarrow\bot$. Найдите лямбда-выражения, доказывающие:
\begin{enumerate}
\item Формулу де-Моргана $\neg(\alpha\vee\beta)\to\neg\alpha\with\neg\beta$.
\item Контрапозицию $(\alpha\to\beta)\to(\neg\beta\to\neg\alpha)$.
\item Закон исключённого третьего после применения теоремы Гливенко $\neg\neg(\alpha\vee\neg\alpha)$.
\end{enumerate}

\item Какие аксиомы соответствуют базису $BCKW$? Покажите, что аксиома, соответствующая $S$,
доказывается в этой аксиоматике.

\item Выразите в Хаскеле $Y$-комбинатор. Каков его тип?

\item Покажите, что типовая система Хаскеля противоречива.

\end{enumerate}

\section*{Домашнее задание №5: <<Реконструкция типа лямбда-выражений в просто-типизированном исчислении>>}
\begin{enumerate}
\item На лекции вводилась метрика для доказательства завершаемости алгоритма унификации: упорядоченная тройка $\langle x,y,z \rangle$,
где $x$ --- количество уравнений в разрешённой форме (уравнений вида $a = \theta$, причём $a$ входит в систему ровно один раз), 
$z$ --- количество уравнений типа $a=a$ и $\theta=b$. Смысл же параметра $y$ не был раскрыт.

Каким взять параметр для $y$, чтобы получившаяся метрика строго монотонно убывала при каждом применении правил унификации?

\item Применив алгоритм, рассказанный на лекции, найдите тип для комбинатора $S$.
\item Применив алгоритм, рассказанный на лекции, покажите отсутствие типа у $Y$-комбинатора.

\item Исчислением предикатов второго порядка назовём исчисление со следующим языком:
$$\Phi ::= x | (\Phi \rightarrow \Phi) | (\forall x.\Phi)$$
Содержательное отличие от исчисления высказываний --- наличие квантора всеобщности и правил вывода для его введения и удаления: 

    \[ \dfrac{\Gamma\vdash\phi}{\Gamma\vdash\forall p.\phi} (p\notin FV(\Gamma)) \qquad
        \dfrac{\Gamma\vdash\forall p.\phi}{\Gamma\vdash\phi[p:=\Theta]} \]

Докажите, что следующие связки могут быть выражены в таком исчислении (то есть, покажите, что сооветствующие формулы
удовлетворяют соответствующим правилам вывода для интуиционистского исчисления высказываний):
\begin{enumerate}
\item $\psi \with \varphi := \forall g.(\psi \rightarrow \varphi \rightarrow g) \rightarrow g$
\item $\psi \vee \varphi := \forall g.(\psi \rightarrow g) \rightarrow (\varphi \rightarrow g) \rightarrow g$
\item $\bot := \forall a.a$
\item $\exists a.\psi := \forall g.(\forall a.(\psi \rightarrow g)) \rightarrow g$

Для квантора существования правила вывода следующие:
    \[ \dfrac{\Gamma\vdash\varphi[p:= \psi]}{\Gamma\vdash\exists p.\varphi}\qquad
        \dfrac{\Gamma\vdash\exists p.\varphi\quad\Gamma, \varphi\vdash\psi}{\Gamma\vdash\psi} (p\notin FV(\Gamma, \psi)) \]
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №6: <<Логика второго порядка и система F>>}
\begin{enumerate}
\item Требуется ли свобода для подстановки в правилах с квантором?

    \[ \dfrac{\Gamma\vdash\phi}{\Gamma\vdash\forall p.\phi} (p\notin FV(\Gamma)) \qquad
        \dfrac{\Gamma\vdash\forall p.\phi}{\Gamma\vdash\phi[p:=\theta]} \]

Если да --- приведите пример доказуемой при отсутствии свободы для подстановки, но некорректной формулы. 
Если нет --- предложите доказательство корректности правил при любых подстановках.

\item Пусть $\Gamma\vdash\varphi$. Всегда ли можно перестроить доказательство $\varphi$, добавив ещё одну гипотезу:
$\Gamma,\psi\vdash\varphi$? Если нет, каковы могли бы быть ограничения на $\psi$?

\item Пусть $\Gamma\vdash\forall x.\varphi$. Верно ли тогда, что $\Gamma\vdash\forall y.\varphi[x := y]$? 
Если это неверно в общем случае, возможно, это верно при каких-то ограничениях? В случае наличия ограничений
приведите надлежащие контрпримеры.

\item Перенесите в систему $F$ из бестипового лямбда-исчисления следующие функции (приведите выражение, укажите его тип и докажите его):
\begin{enumerate}
\item инъекции и $case$ (операции с алгебраическим типом);
\item истина, ложь, исключающее или;
\item черчёвский нумерал (он должен иметь тип $\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow(\alpha\rightarrow\alpha)$) и инкремент;
\item возведение в степень: $\lambda m.\lambda n.n\ m$;
\item вычитание единицы (трюк зуба мудрости) и вычитание.
\end{enumerate}

\item Напомним определения с лекции:

 	$$\infer{\Gamma\vdash (\text{pack } M, \theta \text{ to } \exists \alpha . \varphi) : \exists \alpha.\varphi}{\Gamma \vdash M : \varphi[\alpha := \theta]}
 	 \quad\infer[\alpha \notin FV(\Gamma, \psi)]{\Gamma \vdash \text{abstype } \alpha \text{ with } x:\varphi \text{ in } M \text{ is } N:\psi}{\Gamma \vdash M : \exists \alpha . \varphi\qquad\Gamma, x : \varphi \vdash N : \psi}
	$$

Покажите, что pack и abstype могут быть заданы так:

	$$	\text{\textbf{pack} } M, \theta \text{ \textbf{to} } \exists \alpha . \varphi =
		\Lambda \beta . \lambda x^{\forall \alpha . \varphi \to \beta} . x \theta M $$
	$$	\text{\textbf{abstype} } \alpha \text{ \textbf{with} } x:\varphi \text{ \textbf{in} } M \text{ \textbf{is} } N:\psi =
		M \psi (\Lambda \alpha . \lambda x ^ \varphi . N)
	$$

То есть, соответствующие правила вывода будут выполнены для так заданных выражений.
\item У правил вывода с кванторами для системы $F$ есть ограничения. Покажите, что эти ограничения существенны: что без них 
с помощью кванторов можно типизировать лямбда-выражения, разрушающие систему $F$ (то есть, нарушающие какие-то её существенные
свойства, например, делающие её противоречивой).
\item \begin{enumerate}
\item Разработайте интерфейс и реализацию для абстрактного типа данных <<множество>> (функции создания пустого множества, 
добавления, удаления, проверки наличия элемента в множестве). Напишите тестовую программу, использующую данный АТД.
\item Сделайте по АТД <<множество>> соответствующий экзистенциальный тип в системе F, перенесите его в Хаскель и дайте
реализацию этого типа. Приспособьте тест из предыдущего пункта.
\end{enumerate}

\item Переформулируйте систему F в исчислении по Карри: укажите новые схемы аксиом для кванторов всеобщности и существования.
\item Переформулируйте операции abstype и pack для исчисления по Карри, укажите соответствующие им лямбда-выражения
и покажите, что эти выражения соответствуют аксиомам.
\end{enumerate}

%\item задача про введение существования (ограничения на G|-\phi[p:=psi] и G,\forall p.\phi->g |- \phi[p:=psi]; можем
%ли ослабить доказательство формулой?)

\section*{Домашнее задание №7: <<Типовая система Хиндли-Милнера>>}
\begin{enumerate}
\item Приведите правило вывода (обозначавшееся на лекции как $7'$), типизирующее \verb!let! для рекурсивной функции:
\begin{verbatim}
let rec x = A in B
\end{verbatim}
Покажите, что это правило делает систему противоречивой.
\item Покажите, что если два логических выражения в логике второго порядка эквивалентны ($\vdash\varphi\rightarrow\psi$ и
$\vdash\psi\rightarrow\varphi$), то соответствующие типы либо одновременно обитаемы, либо одновременно необитаемы.
\item Покажите, как по значению типа $\forall \alpha.\beta\rightarrow\varphi(\alpha)$ строить значение типа
$\beta \rightarrow \forall \alpha.\varphi(\alpha)$ и наоборот $\alpha \notin FV(\beta)$.
\item Типовая система Хиндли-Милнера типизирована по Чёрчу. Измените правила и язык так, чтобы она стала типизирована
по Карри.

\item \emph{О выразительной силе HM.} Заметим, что список --- это <<параметризованные>> числа в 
аксиоматике Пеано. Число --- это длина списка, а к каждому штриху мы присоединяем какое-то значение.
Операции добавления и удаления элемента из списка --- это операции прибавления и вычитания
единицы к числу.

Рассмотрим тип <<бинарного списка>>:

\begin{verbatim}
type 'a bin_list = Nil | Zero of (('a*'a) bin_list) | One of 'a * (('a*'a) bin_list);;
\end{verbatim}

Если бы такое можно было выразить в типовой системе Хиндли-Милнера, то операция добавления
элемента к списку записалась бы на языке Окамль вот так (сравните с прибавлением 1 к числу
в двоичной системе счисления):

\begin{verbatim}
let rec add elem lst = match lst with
    Nil -> One (elem,Nil)
  | Zero tl -> One (elem,tl)
  | One (hd,tl) -> Zero (add (elem,hd) tl)
\end{verbatim}

\begin{enumerate}
\item Какой тип имеет \verb!add! (обратите внимание на ключевое слово \verb!rec!: для 
точного указания соответствующего лямбда-выражения и вывода типа необходимо использовать Y-комбинатор)?
Считайте, что семейство типов \verb!bin_list 'a! предопределено, и обозначается как $\tau_\alpha$.
Также считайте, что определены функции roll и unroll с надлежащими типами.
\item Какой ранг имеет тип этой функции? Почему этот тип не выразим в типовой системе Хиндли-Милнера?
\item Предложите функцию для удаления элемента списка (головы).
\item Предложите функцию для эффективного соединения двух списков (источник для 
вдохновения --- сложение двух чисел в столбик).
\item Предложите функцию для эффективного выделения $n$-го элемента из списка.
\end{enumerate}

\item Рассмотрим следующий код на Окамле, содержащий определения чёрчевских нумералов
и некоторых простых операций с ними:

\begin{verbatim}
let zero = fun f x -> x;;
let plus1 a = fun f -> fun x -> a f (f x);;
let power m n = n m;;

let two = plus1 (plus1 zero);;
let two2 = fun f x -> f (f x);;

let e  = power two two;;          (* не компилируется *)
let e2 = power two2 two2;;        (* компилируется и работает *)
\end{verbatim}

Поясните, почему:
\begin{enumerate}
\item определение $e2$ компилируется и работает;
\item определение $e$ не компилируется.
\end{enumerate}

Пояснение должно содержать необходимые фрагменты вывода типа в системе Хиндли-Милнера, 
или должно показывать, что нужного вывода типа не существует.

\item Какой ранг имеют экзистенциальный тип и тип монады \verb!ST! из Хаскеля?
\end{enumerate}

\section*{Домашнее задание №8-9: <<Обобщённая типовая система; язык Аренд>>}

\begin{enumerate}
\item Укажите тип (род) в исчислении конструкций для следующих выражений (при необходимости определите
типы используемых базовых операций и конструкций самостоятельно):
\begin{enumerate}
\item В алгебраическом типе \verb!'a option = None | Some 'a! предложите тип (род) для: \verb!Some!,
\verb!None! и \verb!option!.
\item Пусть задан род $\textbf{nonzero}: \star\rightarrow\star$, выбрасывающий нулевой элемент из
типа. Например, $\textbf{nonzero}\ \textbf{unsigned}$ --- тип положительных целых чисел.
Тогда, для кода
\begin{verbatim}
template<typename T, T x>
struct NonZero { const static std::enable_if_t<x != T(0), T> value = x; };
\end{verbatim}
предложите тип (род) поля value.
\end{enumerate}

\item Предложите выражение на языке C++ (возможно, использующее шаблоны), имеющее следующий род (тип):
\begin{enumerate}
\item $\star\rightarrow\star\rightarrow\star$; $\ \star\rightarrow\textbf{unsigned}$
\item $\textbf{int}\rightarrow(\star\rightarrow\star)$
\item $(\star\rightarrow\textbf{int})\rightarrow\star$
\item $\Pi x^\star.n^\textbf{int}.F(n,x)$, где $$F(n,x) = \left\{\begin{array}{ll}\textbf{int}, & n = 0\\
                                   x\rightarrow F(n,x), & n > 0\end{array}\right.$$
\end{enumerate}

\item Определите функции из следующих частей $\lambda$-куба (в обобщённой типовой системе) и докажите их тип:
\begin{enumerate}
\item $(\square,\star)$
\item $(\star,\square)$
\item $(\square,\square)$
\end{enumerate}

\item Рассмотрим правый дальний нижний угол $\lambda$-куба ($\{(\star,\star);(\star,\square);(\square,\star)\}$).
Можно предположить, что тогда в такой системе возможны и функции рода $f: \star\rightarrow\star$ 
(как композиция функций $p: \star\rightarrow\alpha$ и $q: \alpha\rightarrow\star$ ---
например, можно кодировать тип его именем, затем по имени типа восстанавливать сам тип обратно).
Почему всё-таки такие функции в обобщённых типовых системах невозможны без четвёртого элемента $(\square,\square)$?

\item Как отмечалось на занятии, мы рассматриваем множество натуральных чисел как множество с дискретной топологией
(для того, чтобы функции из $Nat$ в $Nat$ были бы непрерывны). Поясните, почему дискретная топология гарантирует
непрерывность любой такой функции? Напомним, что непрерывная функция --- такая, у которой любой прообраз открытого
множества открыт.
                                                    
\item Какова должна быть топология на множестве
пар натуральных чисел (интуитивно мы будем понимать эти пары как рациональные числа, пары <<числитель-знаменатель>>), 
чтобы непрерывными были бы те и только те функции, для которых выполнено $f(p,q) = f(p',q')$ для всех 
таких $p,p',q$ и $q'$, что $p\cdot q' = p'\cdot q$. Напомним, что равенство мы понимаем как наличие непрерывного пути 
между точками.

\item Докажите, приведя компилирующуюся программу на языке Аренд (возможно, вам потребуются функции и приёмы, 
изложенные в документации по языку: \url{https://arend-lang.github.io/documentation/tutorial/PartI/}):
\begin{enumerate}
\item ассоциативность сложения;
\item коммутативность сложения;
\item коммутативность умножения;
\item дистрибутивность: $(a + b)\cdot c = a\cdot c + b \cdot c$;
\item куб суммы: $(a + 1)^3 = a^3 + 3\cdot a^2 + 3 \cdot a + 1$.
\end{enumerate}

\item Определим, что $x$ делится на $p$, если обитаем тип \verb!\Sigma (q : Nat) (p * q = x)!.
\begin{enumerate}
\item Покажите, что если $x$ делится на 6, то $x$ делится и на 3;
\item Покажите, что $x!$ делится на $x$;
\item Покажите, что если $x$ делится на $y$ и $y$ делится на $z$, то $x$ делится на $z$;
\end{enumerate}

\item Определите предикат (т.е. функцию с надлежащим типом) для формализации понятия простого числа \verb!isPrime!.
Покажите, что:
\begin{enumerate}
\item 3 и 11 --- простые числа;
\item Произведение простых чисел непросто;
\item 2 --- единственное чётное простое число.
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №10: <<Ещё доказательства>>}

\begin{enumerate}
\item Покажите, что если на множестве пар $Q = \mathbb{N}_0 \times \mathbb{N}$ задана топология
с базой $$B = \{ S \subseteq Q | \forall \langle p,q \rangle.\forall \langle p',q' \rangle.p\cdot q' = p' \cdot q \}$$
то все функции $f: Q \rightarrow X$, для которых выполнено $f(\langle p,q\rangle) \rightsquigarrow f(\langle p',q'\rangle)$ для всех 
таких $p,p',q$ и $q'$, что $p\cdot q' = p'\cdot q$ --- непрерывны (волнистую стрелку мы понимаем как наличие непрерывного пути
в пространстве $X$). 

\item Определим отношение <<меньше>> на натуральных числах так (с помощью индуктивного типа, обобщения алгебраического типа данных ---
зависимого типа, в котором при разных значениях аргументов типа допустимы разные конструкторы):
\begin{verbatim}
\data NatLessEq (a b : Nat) \with
  | 0, m => natlesseq-zero
  | suc m, suc n => natlesseq-next (NatLessEq m n)
\end{verbatim}
                                                                                                      
Например, конструктор \verb!natlesseq-zero! можно использовать только если первый аргумент типа --- число 0.
А конструктор \verb!natlesseq-next! применим только если первый аргумент больше 0; при этом данный конструктор
требует значение типа с определёнными аргументами в качестве своего аргумента.

Будем говорить, что $a \preceq b$ тогда и только тогда, когда \verb!NatLessEq a b! обитаем.
Например, утверждение $1 \preceq 3$ доказывается так:

\begin{center}\verb!\func one-le-three : NatLessEq 1 3 => natlesseq-next (natlesseq-zero)!\end{center}

\emph{В самом деле}, \verb!natlesseq-zero! может являться конструктором типа \verb!NatLessEq 0 b!,
а тогда \begin{center}\verb!natlesseq-next (natlesseq-zero) : NatLessEq 1 (b+1)!\end{center} Унифицировать $b+1$ и $3$
компилятор (в данном случае) может самостоятельно, и потому код выше проходит проверку на корректность.

Докажите (везде предполагается, что $a,b,c : \texttt{Nat}$, если не указано иного):
\begin{enumerate}
\item $a \preceq b$ тогда и только тогда, когда $a$ меньше или равно $b$ в смысле натуральных чисел (здесь требуется рассуждение
на мета-языке).
\item $a \preceq a + b + 1$; то есть, определите функцию\\\verb!\func n-less-sum (a b : Nat) : NatLessEq a (a Nat.+ suc b)!
\item Если $a \preceq b$, то $a + c \preceq b + c$
\item Если $a \preceq b$ и $c \preceq d$, то $a \cdot c \preceq b \cdot d$
\item $a \preceq 2^a$
\item Транзитивность: если $a \preceq b$ и $b \preceq c$, то $a \preceq c$
\item $a \preceq b \vee b \preceq a$
\item Найдите стандартное определение отношения <<меньше>> в библиотеке Аренда (\verb!Nat.<!) и докажите, что $a \preceq b$ 
тогда и только тогда, когда $a < b$ или $a = b$ (реализуйте функции \\\verb!there (p : NatLessEq a b) : Data.Or (a Nat.< b) (a = b)!
и обратную к ней).
\item Покажите, что $a \preceq b$ тогда и только тогда, когда $\exists k^{\mathbb{N}_0}.a + k = b$.
\end{enumerate}

\item С точки зрения изоморфизма Карри-Ховарда индуктивные типы можно воспринимать как аналоги предикатов.
В этом задании надо построить индуктивные типы для различных предикатов:
\begin{enumerate}
\item Факториал (\verb!IsFact n!), который будет обитаем только для таких $n$, что $n = k!$.
Докажите на языке Аренд, что \verb!IsFact! $(1 \cdot 2 \cdot 3 \cdot \dots \cdot n)$ всегда обитаем, а
тип \verb!IsFact 3! --- необитаем.
\item Наибольший общий делитель двух чисел \verb!GCD x a b!; \emph{указание/пожелание:} воспользуйтесь алгоритмом Эвклида.  
\item Ограниченное натуральное число \verb!IndFin n!, обитателями типа являются только те числа, которые меньше $n$.
В стандартной библиотеке \verb!Fin! определён через натуральные числа; 
сделайте это исключительно через индуктивные типы. Покажите, что если \verb!x : IndFin m! и \verb!y : IndFin n!,
то \verb!x + y : IndFin (m + n)!.
\end{enumerate}

\item Определите тип \verb!Perm n! --- его элементами должны быть те и только те списки чисел, которые являются перестановкой
$n$ элементов --- и покажите, что:
\begin{enumerate}
\item $0,1,2,\dots,n-1$ --- перестановка $n$ элементов;
\item определите, чему равна сумма всех элементов перестановки --- и докажите что это действительно так для любого $n$;
\item всего существует $6$ элементов в типе \verb!Perm 3! (то есть, существует такой список из 6 элементов,
каждые два элемента которого не равны друг другу, и если \verb!x : Perm 3!, то $x$ --- элемент данного списка).
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №11: <<Элиминаторы; предикативные уровни>>}
\begin{enumerate}
\item Чтобы было проще решать задачи из предыдущего задания, давайте решим дополнительную задачу
на похожую тему. Рассмотрим следующее доказательство уникальности элементов списка:
\begin{verbatim}
\func not-member (A : \Type) (elem : A) (l : List A) : \Type \elim l
  | nil => \Sigma
  | :: hd tl => \Sigma (Not (hd = elem)) (not-member A elem tl)

\func unique-list (A : \Type) (l : List A) : \Type \elim l
  | nil => \Sigma
  | :: hd tl => \Sigma (not-member A hd tl) (unique-list A tl)
\end{verbatim}

Докажем, что список $[0,1,2]$ состоит из уникальных элементов:
\begin{verbatim}
\func r-unique => unique-list Nat (0 :: 1 :: 2 :: nil)
\func x : r-unique => ((contradiction, (contradiction, ())), ((contradiction, ()), ((), ())))
\end{verbatim}

\begin{enumerate} 
\item Напишите функцию, строящую список \verb!b! натуральных чисел от 0 до n и доказательство\\ \verb!unique-list Nat b!.
\item Покажите, что если $a_0 < a_1 < \dots < a_n$, то список $[a_0,a_1,\dots,a_n]$ уникальный.
\item Покажите, что если $n \ge 2$ и $a_k \ne a_{k+1}$ при $0 \le k < n$, то необязательно, что список
$[a_0,a_1,\dots,a_n]$ --- уникальный.
\end{enumerate}

\item Как вы помните из лекции, в языке Аренд существует иерархия вложенных типовых универсумов. Если в типе отсутствует
упоминание \verb!\Type!, то данный тип принадлежит универсуму 0. Однако, если в типе упоминается \verb!\Type k!,
то тип принадлежит универсумам, не меньшим $k+1$. Уровень универума обозначается специальным ключевым словом \verb!\lp!.
Над индексами можно проводить простые операции и сопоставление с образцом (\verb!\suc\lp!). Более подробно
можно это прочесть в документации по языку Аренд:

\url{https://arend-lang.github.io/documentation/tutorial/PartI/universes.html}
%\begin{enumerate}
%\item Определите функцию \verb!\id!, возвращающую 
%\end{enumerate}

Рассмотрим определения:
\begin{verbatim}
\func ChurchT (x : \Type) => (x -> x) -> (x -> x)
\func Church => \Pi (x : \Type) -> ChurchT x
\func Zero : Church => \lam t f x => x

\func incT (t : \Type) (n : ChurchT t) => \lam f x => n f (f x)
\func pair_plus (type : \Type) (pair : \Sigma (ChurchT type) (ChurchT type)) :
  \Sigma (ChurchT type) (ChurchT type) => (pair.2, incT type pair.2)
\func dec (n : Church) : Church => \lam (t : \Type) =>
    (n (\Sigma (ChurchT t) (ChurchT t)) (pair_plus t) (Zero t, Zero t)).1
\func sub (a : Church (\suc\lp)) (b : Church) => a (Church \lp) dec b
\end{verbatim}

Определите, развивая определения выше:
\begin{enumerate}
\item Операцию умножения.
\item Операцию <<деление на три>> (естественно, в версии, не использующей $Y$-комбинатор).
\item Операцию возведения в степень, определявшуюся как $\lambda m.\lambda n.n\ m$.
\item Деление.
\item Вычисление факториала.
\end{enumerate}

\item Определите следующие свойства как пропы и покажите, что это так (докажите \verb!isProp! для каждого,
см. стандартную библиотеку):
\begin{enumerate}
\item Натуральное число простое.
\item Натуральное число не делится на 3.
\item $x$ и $y$ натуральные, $x < y$.
\item Натуральное число --- полный квадрат.
\item Два натуральных числа имеют <<нетривиальный>> (не равный 1 или одному из этих чисел) общий делитель.
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №12: <<Гомотопические уровни>>}

\begin{enumerate}
\item Напомним тип данных \verb!IsEven! из лекции:

\begin{verbatim}
\data IsEven (n : Nat) \elim n
  | 0 => zero-is-even
  | (suc (suc k)) => next-next (IsEven k)
\end{verbatim}

Доказать, что этот тип является утверждением, можно например так:

\begin{verbatim}
\func all-even-different (n : Nat) (a b : IsEven n) : a = b \elim n, a, b
  | 0, zero-is-even, zero-is-even => idp
  | suc (suc n), next-next a, next-next b => pmap next-next (all-even-different n a b)

\func is-even-isProp (n : Nat) : isProp (IsEven n) => all-even-different n
\end{verbatim}

Обратите внимание: по переменным $n$, $a$ и $b$ производится \emph{элиминация}, то есть множество 
значений переменных разбивается на фрагменты (в соответствии с конструкторами типа данных), 
и доказательство утверждения проводится независимо для каждого фрагмента; 
в частности, цель доказательства изменяется и просходит замена переменных $a$ и $b$ на сопоставляемые
варианты (вместо ожидаемого типа \verb!a = b! мы ожидаем тип \verb!zero-is-even = zero-is-even!, и т.п.).
Сравните с лекцией про элиминаторы, каждый из вариантов --- тело отдельной функции-элиминатора. 

Чтобы воспроизвести тот же эффект в конструкции \verb!\case!, нужно указывать ключевое слово 
\verb!\elim! перед каждой элиминируемой переменной: 
\begin{verbatim}
\case \elim n, \elim a, \elim b \with { ... }
\end{verbatim}

Полный код, определяющий тип \verb!IsEven! (вместе с доказательством того, что тип --- утверждение),
выглядит так:

\begin{verbatim}
\data IsEven (n : Nat) \elim n
  | 0 => zero-is-even
  | (suc (suc k)) => next-next (IsEven k)
  \where {
    \func all-even-different ... -- скопируйте код функции сюда
    \use \level is-even-isProp (n : Nat) : isProp (IsEven n) => all-even-different n
  }
\end{verbatim}

Однако, незавершённым остаётся доказательство разрешимости типа \verb!IsEven n!. Восполните лакуны:

\begin{verbatim}
\func even-is-dec (a : Nat) : Dec (IsEven a) \elim a
  | 0 => yes zero-is-even
  | 1 => no {?}
  | suc (suc a) => {?}
\end{verbatim}

\item Справедливости ради, в предыдущем задании компилятор сам может догадаться, что \verb!IsEven! --- утверждение.
Но далеко не для всех типов это очевидно, и тогда функция с префиксом \verb!\use \level! становится необходимой.
Например, в следующем типе <<простое число>> данная функция должна доказать, что любые два значения типа при данном $x$ равны:

\begin{verbatim}
\data Div3 (x : Nat)
  | remainder-zero (Exists (p : Nat) (p Nat.* 3 = x))
  | remainder-one (Exists (p : Nat) (p Nat.* 3 Nat.+ 1 = x))
  | remainder-two (Exists (p : Nat) (p Nat.* 3 Nat.+ 2 = x))
  \where \use \level levelProp {x : Nat} (a b : Div3 x) : a = b => {?}
\end{verbatim}

\begin{enumerate}
\item Замените \verb!{?}! в тексте выше на корректное доказательство.
\item Определите функцию, которая бы по $x$ и значению $\exists p q.3 \cdot p + q = x \with 0 \le q < 3$ возвращала бы \verb!Div3 x!
(понятно, можно разделить $x$ на 3, но нам уже результат деления дали вторым аргументом --- задача в том, чтобы им воспользоваться).
\item Постройте аналогичный тип \verb!Prime x! для простых чисел --- с тремя вариантами \verb!less-than-two!, \verb!is-prime!, 
\verb!is-composite! --- и определите функцию, строящую по числу значение данного типа.
\item Покажите, что в типе \verb!Prime (x*x + 2*x + 1)! всегда (кроме граничных случаев) обитает вариант \verb!is-composite!.
\item Покажите, что в типе 
\begin{verbatim}
\data SuperDec (P : \Prop)
| sure P
| nope (P -> Empty)
| neither ((P || (P -> Empty)) -> Empty)
\where \use \level superDecProp {P : \Prop} (a b : SuperDec P): a = b => {?}
\end{verbatim}
вариант \verb!neither! невозможен (также, заполните пропущенное доказательство \verb!superDecProp!).
\end{enumerate}

\item Рассмотрим определение целых чисел как упорядоченной пары: $\langle a,b\rangle \subseteq \mathbb{N}^2$,
причём $\langle a,b\rangle \approx \langle c,d\rangle$, если $a + d = b + c$. Построим соответствующий тип
данных, $\mathbb{N}^2/\approx$:

\begin{verbatim}
\data Integer
  | int_data (l r : Nat)
  | int_eq (a b c d : Nat) (a Nat.+ d = b Nat.+ c) : int_data a b = int_data c d
\end{verbatim}

Обратите внимание на второй конструктор \verb!int_eq! --- это специальный конструктор для отношения эквивалентности,
он постулирует равенство между элементами, и его можно использовать для доказательства такого равенства.
Указание на особую роль конструктора --- указание его типа, и значением конструктора являются не сами элементы типа
\verb!Integer! (как это имеет место в случае \verb!int_data!), а пути между элементами типа \verb!Integer!.
Покажем, например, что $[\langle 1,3\rangle] = [\langle 0,2\rangle]$:

\begin{verbatim}
\func r : int_data 1 3 = int_data 0 2 => int_eq 1 3 0 2 idp
\end{verbatim}

Теперь мы можем определить функции на целых числах:

\begin{verbatim}
\func inc (a : Integer) : Integer \elim a
  | int_data l r => int_data (suc l) r
  | int_eq a b c d proof => int_eq (suc a) b (suc c) d (pmap suc proof)
\end{verbatim}

Обратите внимание, мы должны указать не только образы для всех элементов \verb!Integer! (первый случай), но и показать, что 
равные элементы перешли в равные (второй случай).
А именно, нам потребовалось доказать, что операция прибавления 1 вернёт эквивалентные числа для эквивалентных аргументов:
если $\langle a,b\rangle \approx \langle c,d\rangle$, то $\langle a+1, b\rangle \approx \langle c+1,d\rangle$.

\begin{enumerate}
\item Определите функцию \verb!isPositive : Integer -> \Type!, результат которой обитаем тогда и только тогда,
когда аргумент --- положительное число.
\item Покажите \verb!Dec (isPositive k)! для любого целого $k$.
\item Определите функцию \verb!dec : Integer -> Integer!, уменьшающую число на 1.
\item Докажите, что \verb!inc (dec x) = x!.
\item Определите функцию \verb!abs : Integer -> Nat!, возвращающую модуль целого числа.
\item Определите функцию \verb!plus : Integer -> Integer -> Integer!, складывающую два числа.
\end{enumerate}

\item Заметим, что получившийся тип \verb!Integer! множеством (\verb!\Set!) не будет. Чтобы такое выполнялось, необходимо
показать равенство равенств элементов ($\Pi x^\texttt{Integer}.\Pi y^\texttt{Integer}.\Pi a^{x = y}.\Pi b^{x = y}.a = b$). 
Это можно сделать (точнее, \emph{постулировать}), например, с помощью конструкции \verb!\truncate!:

\begin{verbatim}
\truncate \data Integer : \Set
  | int_data (l r : Nat)
  | int_eq (a b c d : Nat) (a Nat.+ d = b Nat.+ c) : int_data a b = int_data c d
\end{verbatim}

И далее, чтобы показать равенство равенств, мы сможем воспользоваться библиотечной функцией \verb!Path.inProp!
(без указания \verb!\truncate! данный код не скомпилируется):

\begin{verbatim}
\func integer_eq (x y : Integer) (p1 p2 : x = y) : p1 = p2 => Path.inProp p1 p2
\end{verbatim}

\begin{enumerate}
\item Поясните (на метаязыке, с точки зрения топологии), почему неусечённый тип \verb!Integer! --- не множество. \emph{Указание:} 
заметим, что путь $\langle 0, 0\rangle = \langle 0, 0 \rangle$ можно получить композицией путей $\langle 0, 0 \rangle = \langle 1,1 \rangle$
и $\langle 1, 1\rangle = \langle 0, 0 \rangle$.
\item Определите функцию \verb!isSet: \Type -> \Type!, результат которой обитаем если исходный тип является множеством ---
в качестве источника вдохновения можно взять \verb!isProp!.
Докажите, что \verb!Nat! --- множество.
\item Использовать конструкцию \verb!\truncate! необязательно --- вместо неё можно указать надлежащий дополнительный конструктор
равенства (теперь для путей) --- и указать надлежащую функцию \verb!\use \level!:
\begin{verbatim}
 | eq_eq (a b : Integer) (p1 p2 : a = b) : p1 = p2
  \where { \use \level asSet ... }
\end{verbatim}

Дополните описание типа данных так, чтобы тип данных \verb!Integer! оказался множеством без специальной конструкции 
\verb!\truncate! (убедитесь, что Path.inProp p1 p2 теперь определён для путей на \verb!Ingeger!, 
и поэтому аналог \verb!integer_eq! скомпилируется).
Также исправьте определение функции \verb!inc! из прошлого задания.

\end{enumerate}

\item Рассмотрим аксиому для квантора существования из исчисления предикатов (в гильбертовской форме):
\begin{verbatim}
\func exists-axiom {T : \Type} {A : T -> \Prop} (evidence : T) (proof : A evidence) 
    : Exists (x : T) (A x) => inP (evidence, proof)
\end{verbatim}

Сформулируйте и докажите:
\begin{enumerate}
\item правило вывода из исчисления предикатов;
\item правило удаления квантора существования из исчисления предикатов в натуральном выводе:
$$\infer{\vdash\psi}{\vdash\exists x.\varphi(x)\quad\quad \varphi(\theta)\vdash\psi}$$
\end{enumerate}

\item Научимся раскрывать усечённый тип данных (при возможности это сделать):
\begin{enumerate}
\item По $\exists p.p' = x$ постройте такой $p$, что $p' = x$: 
\begin{verbatim}\func safe-dec (x : Nat) (Exists (p : Nat) (suc p = x)) : \Sigma (p : Nat) (suc p = x)\end{verbatim}
\emph{Указание: } второй параметр нужен для того, чтобы исключить вариант $x = 0$.
\item По \verb!not-equals : (x > y || x < y)! при \verb!x y : Nat! 
(обратите внимание, здесь применяется усечённое <<или>>) получите \verb!x /= y!.
\item По \verb!x : Nat! и \verb!p : Exists (p : Nat) (p * p = x)! найдите
\verb!\Sigma (p : Nat) (p * p = x)! (мы здесь должны существенно использовать единственность натурального корня числа).
\end{enumerate}

\item В предыдущих заданиях мы строили фактор-множества вручную. То же можно сделать с помощью библиотечного типа данных \verb!Quotient!.
\begin{enumerate}
\item Постройте тип множества рациональных положительных чисел \verb!Rational! как фактор-множество пар $\langle a,b \rangle$ и $\langle c,d \rangle$
по отношению <<равны как простые дроби>>:
$\langle a, b \rangle \approx \langle c, d \rangle$, если $a\cdot d = b \cdot c$ ($a,c \in \mathbb{N}_0$, $b,d \in \mathbb{N}$).
\item Определите арифметические операции (сложение, умножение).
\item Постройте функцию \verb!to_rat (arg: Nat) : Rational! и \verb!from_rat! (выполняющую округление вниз). Покажите, что 
\verb!\Pi (x : Nat) -> x = from_rat (to_rat x)!.
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №13. Линейная логика. Теорема Диаконеску.}

Данное задание (неявно) использует разобранную на лекции статью Филиппа Вадлера <<A tase of linear logic>>, её можно найти тут:

\url{https://homepages.inf.ed.ac.uk/wadler/papers/lineartaste/lineartaste-revised.pdf}

\begin{enumerate}
\item Как известно, интуиционистские связки могут быть выражены в линейном исчислении.
Покажите соответствующие интуиционистские аксиомы для следующих способов выразить интуиционистские связки
через линейные:
\begin{enumerate}
\item $A \rightarrow B :=\ !A \multimap B$
\item Интуиционистская дизъюнкция: $A + B :=\ !A \oplus !B$
\item Интуиционистская конъюнкция: $A \times B := A \with B$
\item Альтернативная конъюнкция: $A \times B :=\ !A \otimes !B$ 
\item Покажите, что альтернативная конъюнкция влечёт обычную, но не наоборот: $\langle!A \otimes !B\rangle \vdash A \with B$,
но $\langle A \with B\rangle \not\vdash \ !A \otimes !B$.
\end{enumerate}

\item Покажите следующие линейные тождества:
\begin{enumerate}
\item $\vdash \phi \multimap \phi$
\item $\vdash \ !\phi \multimap \ !!\phi$
\end{enumerate}

\item Дистрибутивность
\begin{enumerate}
\item Выполняется ли дистрибутивность для $(\&)$ и $(\oplus)$?
\item Выполняется ли дистрибутивность для $(\&)$ и $(\otimes)$?
\end{enumerate}

\item В статье Вадлера структурное правило перестановки гипотез указано так:

$$\infer{\Delta,\Gamma\vdash\alpha}{\Gamma,\Delta\vdash\alpha}$$

Возможно, есть искушение записать это правило так:

$$\infer{\Psi,\Delta,\Gamma,\Xi\vdash\alpha}{\Psi,\Gamma,\Delta,\Xi\vdash\alpha}$$

Требуется ли на самом деле такое правило? Достаточно ли формулировки вверху для получения любой перестановки гипотез?

\item Верно ли, что в языке Аренд \verb!Nat! --- вполне упорядоченное отношением $(\le)$ множество? Докажите, или укажите
свойство, которое необходимо для такого доказательства.
\end{enumerate}

\section*{Домашнее задание №14. Аксиома детерменированности.}

\begin{enumerate}
\item 
Будем говорить, что отношение $R \subseteq A \times A$ тотально, если для любого $x \in A$ существует $y \in A$,
что $\langle x,y \rangle \in R$. 

Будем говорить, что теория соответствует аксиоме зависимого выбора, если для любого тотального отношения $R \subseteq A \times A$
(где $A$ непусто) найдётся такая последовательность $x_0, x_1, x_2, \dots$, что $\langle x_k, x_{k+1} \rangle \in R$.

Покажите, что аксиома зависимого выбора следует из аксиомы выбора.

\item Покажите, что следующие формулировки аксиомы детерминированности эквивалентны:
(a) пусть P счётно; тогда любая игра $P^\omega$ (иными словами, множество выигрышных вариантов --- подмножество $P^\omega$) --- детерминирована
(т.е. в любой момент игры сторонний наблюдатель может сказать, у какого из игроков есть выигрышная стратегия --- и подсказать первый ход
этой стратегии; игры мы считаем бесконечными);
(б) то же, но $P = \{0,1\}$.

Заметим, что в игре Банаха-Мазура условие счётности множества $P$ выполняется.

\item Покажите теорему конечного выбора для аксиоматики ZF: если задана конечная последовательность непустых множеств
($\forall n < N.\exists x.x \in A_n$), то существует функция $f$, что $f(k) \in A_k$.
\emph{Указание:} докажите это по индукции в метаязыке.

%\item Покажите, что аксиома счётного выбора (для $\{ A_n \}$, что $\forall n \in \mathbb{N}.\exists x.x \in A_n$, существует 
%$f: \mathbb{N} \rightarrow \cup A_n$, что $f(k) \in A_k$) следует из аксиомы детерминированности (т.е. придумайте подходящую игру).

\item Является ли $\mathbb{Q}$ множеством первой категории Бэра?

\item Рассмотрим игру Банаха-Мазура для некоторого множества $A$. Восполните лакуны в доказательстве несовместимости
аксиомы детерминированности и аксиомы выбора.
\begin{enumerate}
\item Покажите, что игра всегда заканчивается в пользу (1) игрока (т.е. $\cap I_n \ne \varnothing$), если $A = (0,1)$.
\item У кого есть выигрышная стратегия для $A = \mathbb{Q}$? А для $\mathbb{R} \setminus \mathbb{Q}$?
\item Напомним, что точка $a \in A$ отвергается частичным протоколом $p = \langle I_0, I_1, \dots, I_{2n-1} \rangle$
выигрышной стратегии для (2) игрока, если $a \in I_{2n-1}$ и на любой ход $I_{2n}$ (2) игрок всегда, 
\emph{следуя выигрышной стратегии}, выберет интервал $I_{2n+1}$ так, что $a \notin I_{2n+1}$.

Покажите, что множество $R(p)$ точек, отвергаемых частичным протоколом $p$ --- всюду неплотное.
\emph{Указание:} речь не идёт о составлении отдельной стратегии, отвергающей точку $a$. Речь идёт о исследовании поведения
некоторой уже данной (в условии теоремы) стратегии.
\item Покажите следствие из теоремы: если в игре есть выигрышная стратегия для (1) игрока, то существует интервал $I$,
что $I \setminus A$ --- первой категории Бэра.
\item Покажите вторую часть следствия из теоремы: если существует интервал $I$, что $I \setminus A$ --- первой категории Бэра,
то есть выигрышная стратегия для (1) игрока
\item Пусть $T = \{I_n \ |\ I_n \setminus A \text{ является множеством первой категории Бэра}\}$ и $A' = A \triangle \cup T$. Покажите, что 
$I \setminus A'$ не множество 1 категории Бэра ни при каком $I$.
\item Покажите, что свойство Бэра сохраняется при операциях взятия дополнения, счётного объединения и пересечения.
\item Пусть $V$ --- некоторое множество Витали на отрезке $[0,1]$ (пусть $a\approx b$, если $a-b$ рационально;
тогда возьмём по представителю из каждого элемента фактор-множества $[0,1]/\approx$). Покажите, что как $V$ не является
множеством 1 категории Бэра ни на каком непустом интервале $I' \subseteq I$ ($I' \cap V$), так и его дополнение до 
интервала также не является таким множество ($I' \setminus V$).
\item Покажите, что $V$ не обладает свойством Бэра.
\end{enumerate}
\end{enumerate}

\section*{Дополнительные задания на баллы}

\begin{enumerate}
\item (10 баллов). Определите тип данных, соответствующий сетоиду. Покажите, что теорема Диаконеску выполнена для сетоидов.
\item (10 баллов). Определите отношение мощностей множеств. Покажите теорему Кантора ($|X| < |\mathcal{P}(X)|$). 
\item (10 баллов). Формализуйте ординалы в Аренде (близко к классическому определению), постройте вложение натуральных чисел в ординалы.
Покажите какой-нибудь простой результат про ординалы (например, аксиому бесконечности или что-то подобное).
\item (15 баллов). Покажите малую теорему Ферма (если $p$ -- простое и $a$ не делится на $p$, то $a^{p-1}-1$ делится на $p$.
\end{enumerate}

\end{document}
